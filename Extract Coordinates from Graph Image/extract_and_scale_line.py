# -*- coding: utf-8 -*-
"""extract_and_scale_line.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nFQ3Q47OKxz0qtG_f4QkqYzISbM_bN5D
"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow  # Remove or comment out if not running in Colab


def get_white_line_points_per_x_strip(image_path, num_strips=109, white_threshold=200, y_agg_method='average'):
    """
    Load an image, divide it into vertical strips, find white pixels, and aggregate y-coordinates.

    Args:
        image_path (str): Path to the image file.
        num_strips (int): Number of vertical strips to divide the image into.
        white_threshold (int): Threshold to consider a pixel white (0-255).
        y_agg_method (str): Aggregation method for y values ('average', 'median', 'min', 'max', 'first', 'last').

    Returns:
        List of tuples: (x_center_of_strip, aggregated_y) pixel coordinates of the white line.
    """
    try:
        img = cv2.imread(image_path, cv2.IMREAD_COLOR)
        if img is None:
            print(f"Error: Could not load image from {image_path}")
            return []

        height, width = img.shape[:2]

        gray_img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        _, binary_mask = cv2.threshold(gray_img, white_threshold, 255, cv2.THRESH_BINARY)

        strip_width = width / num_strips
        if strip_width < 1:
            # Adjust num_strips for very narrow strips
            num_strips = width
            strip_width = 1

        representative_points = []

        for i in range(num_strips):
            x_start = int(i * strip_width)
            x_end = int((i + 1) * strip_width)
            if i == num_strips - 1:
                x_end = width

            strip_mask = binary_mask[:, x_start:x_end]

            y_coords, x_coords = np.where(strip_mask == 255)

            if len(y_coords) > 0:
                if y_agg_method == 'average':
                    agg_y = np.mean(y_coords)
                elif y_agg_method == 'median':
                    agg_y = np.median(y_coords)
                elif y_agg_method == 'min':
                    agg_y = np.min(y_coords)
                elif y_agg_method == 'max':
                    agg_y = np.max(y_coords)
                elif y_agg_method == 'first':
                    agg_y = y_coords[0]
                elif y_agg_method == 'last':
                    agg_y = y_coords[-1]
                else:
                    print(f"Unknown y_agg_method '{y_agg_method}', defaulting to 'average'")
                    agg_y = np.mean(y_coords)

                x_center = x_start + (x_end - x_start) // 2
                representative_points.append((x_center, int(round(agg_y))))

        print(f"Found representative points in {len(representative_points)} out of {num_strips} strips.")
        return representative_points

    except Exception as e:
        print(f"Error processing image: {e}")
        return []


def scale_coordinates(coordinates, original_x_range, original_y_range, target_x_range, target_y_range):
    """
    Scale pixel coordinates to data coordinates, optionally handling inverted y-axis.

    Args:
        coordinates (list of (x,y)): Pixel coordinates.
        original_x_range (tuple): (min_x_pixel, max_x_pixel).
        original_y_range (tuple): (min_y_pixel, max_y_pixel).
        target_x_range (tuple): (min_x_data, max_x_data).
        target_y_range (tuple): (min_y_data, max_y_data).

    Returns:
        list of (x_scaled, y_scaled)
    """
    if not coordinates:
        print("No coordinates to scale.")
        return []

    min_xo, max_xo = original_x_range
    min_yo, max_yo = original_y_range
    min_xt, max_xt = target_x_range
    min_yt, max_yt = target_y_range

    x_scale = (max_xt - min_xt) / (max_xo - min_xo) if max_xo != min_xo else 1.0
    y_scale = (max_yt - min_yt) / (max_yo - min_yo) if max_yo != min_yo else 1.0

    scaled = []
    for x_pix, y_pix in coordinates:
        x_scaled = min_xt + (x_pix - min_xo) * x_scale
        y_scaled = min_yt + (y_pix - min_yo) * y_scale
        scaled.append((x_scaled, y_scaled))

    return scaled


def visualize_points(image_path, points, point_color=(0, 255, 0), radius=3):
    """
    Visualize points on the image and show it.

    Args:
        image_path (str): Path to image.
        points (list of (x,y)): Pixel coordinates to plot.
        point_color (tuple): BGR color for points.
        radius (int): Radius of drawn circles.
    """
    img = cv2.imread(image_path, cv2.IMREAD_COLOR)
    if img is None:
        print(f"Cannot load image at {image_path} for visualization.")
        return

    for x, y in points:
        if 0 <= x < img.shape[1] and 0 <= y < img.shape[0]:
            cv2.circle(img, (x, y), radius, point_color, -1)
        else:
            print(f"Point {(x,y)} outside image bounds.")

    print(f"Displaying image with {len(points)} highlighted points.")
    try:
        cv2_imshow(img)  # Comment this out if not in Colab
        # If not in Colab, use cv2.imshow in your local environment instead:
        # cv2.imshow("Line Points", img)
        # cv2.waitKey(0)
        # cv2.destroyAllWindows()
    except Exception:
        # fallback to saving if imshow fails
        cv2.imwrite("output_with_points.png", img)
        print("Image saved as output_with_points.png")


def main():
    # Settings
    graph_image_path = '/content/g4.JPG'  # Change to your image path
    num_vertical_strips = 109
    white_threshold = 200
    aggregation_method = 'average'

    # Step 1: Extract representative points per strip
    rep_points = get_white_line_points_per_x_strip(
        graph_image_path,
        num_strips=num_vertical_strips,
        white_threshold=white_threshold,
        y_agg_method=aggregation_method
    )

    if not rep_points:
        print("No representative points found. Exiting.")
        return

    # Step 2: Get image dimensions for scaling
    img = cv2.imread(graph_image_path, cv2.IMREAD_COLOR)
    if img is None:
        print(f"Could not load image {graph_image_path} for scaling.")
        return

    height, width = img.shape[:2]
    original_x_range_pixels = (0, width - 1)
    original_y_range_pixels = (0, height - 1)

    # Step 3: Define target axis ranges (your graph's data ranges)
    target_x_range_data = (1, 109)
    # For y-axis: invert scaling so pixel y=0 (top) maps to 0.6 (max) and pixel y=height-1 (bottom) maps to 0.0 (min)
    target_y_range_data_inverted = (0.6, 0.0)

    # Step 4: Scale the pixel coordinates to data coordinates
    scaled_points = scale_coordinates(
        rep_points,
        original_x_range_pixels,
        original_y_range_pixels,
        target_x_range_data,
        target_y_range_data_inverted
    )

    # Step 5: Print sample of scaled coordinates
    print(f"\nScaled Coordinates (x: {target_x_range_data[0]}-{target_x_range_data[1]}, y: 0-0.6):")
    num_to_show = min(len(scaled_points), 10)
    for pt in scaled_points[:num_to_show]:
        print(pt)
    if len(scaled_points) > 2 * num_to_show:
        print("...")
        for pt in scaled_points[-num_to_show:]:
            print(pt)
    elif len(scaled_points) > num_to_show:
        for pt in scaled_points[num_to_show:]:
            print(pt)

    # Step 6: Visualize the representative pixel points on the image
    visualize_points(graph_image_path, rep_points)


if __name__ == "__main__":
    main()
